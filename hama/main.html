<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resim → Hama Boncuk Dönüştürücü</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111}
    h1{font-size:20px;margin-bottom:6px}
    label{display:block;margin-top:10px;font-weight:600}
    .row{display:flex;gap:10px;align-items:center}
    input[type=number]{width:90px}
    canvas{border:1px solid #ddd;margin-top:12px}
    .palette{display:flex;gap:6px;margin-top:8px}
    .sw{width:28px;height:28px;border-radius:3px;border:1px solid #ccc}
    button{margin-top:10px;padding:8px 12px;border-radius:8px;border:0;background:#0b74de;color:white}
    small{color:#555}
  </style>
</head>
<body>
  <h1>Resim → Hama Boncuk (HTML Tek Dosya)</h1>
  <p>Bir resmi boncuk ızgarasına çevirir. Çıktı: boncuk ızgarası (PNG) + SVG/ayarlar. (Küçük-resim boyutlarında hızlı çalışır.)</p>

  <label>Resim seç (PNG/JPG/GIF)</label>
  <input id="file" type="file" accept="image/*">

  <div class="row">
    <div>
      <label>Boncuk genişliği (beads across)</label>
      <input id="beadsAcross" type="number" min="8" max="300" value="48">
      <div><small>Resmin yatayda kaç boncuk olacak (diğer boy otomatik)</small></div>
    </div>

    <div>
      <label>Renk sayısı (palette)</label>
      <input id="paletteSize" type="number" min="2" max="64" value="16">
    </div>

    <div>
      <label>Boncuk piksel boyutu</label>
      <input id="beadPx" type="number" min="6" max="64" value="14">
      <div><small>Basılacak PNG için her boncuk kaç px</small></div>
    </div>
  </div>

  <label class="row"><input id="dither" type="checkbox"> <span style="margin-left:8px">Floyd–Steinberg dithering uygula</span></label>

  <div class="row">
    <button id="generate">Oluştur</button>
    <button id="download" disabled>PNG İndir</button>
    <button id="exportCSV" disabled>CSV (boncuk renkleri) İndir</button>
  </div>

  <div id="palettePreview" class="palette"></div>

  <canvas id="preview" width="640" height="480"></canvas>

  <script>
  // Comments in English as requested by user's preferences.

  const fileEl = document.getElementById('file');
  const beadsAcrossEl = document.getElementById('beadsAcross');
  const paletteSizeEl = document.getElementById('paletteSize');
  const beadPxEl = document.getElementById('beadPx');
  const ditherEl = document.getElementById('dither');
  const generateBtn = document.getElementById('generate');
  const downloadBtn = document.getElementById('download');
  const exportCSVBtn = document.getElementById('exportCSV');
  const previewCanvas = document.getElementById('preview');
  const previewCtx = previewCanvas.getContext('2d');
  const palettePreview = document.getElementById('palettePreview');

  let lastGrid = null; // {w,h,grid: [[r,g,b],[...]], palette: [[r,g,b],...]}

  // Utility: clamp
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // Load image from file input
  async function loadImage(file){
    return new Promise((res,rej)=>{
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
      img.onerror = (e)=>rej(e);
      img.src = url;
    });
  }

  // K-means color quantization (simple, small images OK)
  function kmeansQuantize(pixels, k, maxIter=12){
    // pixels: array of [r,g,b]
    if(pixels.length===0) return {palette:[], assignments:[]};
    // initialize centroids by sampling
    const centroids = [];
    for(let i=0;i<k;i++) centroids.push(pixels[Math.floor(Math.random()*pixels.length)].slice());

    let assignments = new Array(pixels.length).fill(0);
    for(let iter=0; iter<maxIter; iter++){
      // assign
      let changed = false;
      for(let i=0;i<pixels.length;i++){
        const p = pixels[i];
        let best = 0, bestD=1e9;
        for(let c=0;c<k;c++){
          const d = (p[0]-centroids[c][0])**2 + (p[1]-centroids[c][1])**2 + (p[2]-centroids[c][2])**2;
          if(d<bestD){bestD=d; best=c}
        }
        if(assignments[i]!==best){ assignments[i]=best; changed=true; }
      }
      // update
      const sums = Array.from({length:k},()=>[0,0,0,0]);
      for(let i=0;i<pixels.length;i++){
        const a = assignments[i];
        sums[a][0]+=pixels[i][0]; sums[a][1]+=pixels[i][1]; sums[a][2]+=pixels[i][2]; sums[a][3]++;
      }
      for(let c=0;c<k;c++){
        if(sums[c][3]===0) continue;
        centroids[c][0]=Math.round(sums[c][0]/sums[c][3]);
        centroids[c][1]=Math.round(sums[c][1]/sums[c][3]);
        centroids[c][2]=Math.round(sums[c][2]/sums[c][3]);
      }
      if(!changed) break;
    }
    return {palette:centroids, assignments};
  }

  // Find nearest palette color index
  function nearestColorIndex(palette, r,g,b){
    let best=0,bestD=1e9;
    for(let i=0;i<palette.length;i++){
      const c=palette[i];
      const d=(r-c[0])**2+(g-c[1])**2+(b-c[2])**2;
      if(d<bestD){bestD=d;best=i}
    }
    return best;
  }

  // Floyd–Steinberg dithering map
  function applyDither(imageData, w, h, palette){
    const data = new Uint8ClampedArray(imageData); // copy
    const get = (x,y,idx)=> (data[(y*w+x)*4 + idx]);
    const set = (x,y,idx,val)=> { data[(y*w+x)*4 + idx]=val; };
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w+x)*4;
        const old = [data[i],data[i+1],data[i+2]];
        const pi = nearestColorIndex(palette, old[0],old[1],old[2]);
        const newc = palette[pi];
        set(x,y,0,newc[0]); set(x,y,1,newc[1]); set(x,y,2,newc[2]);
        const err = [old[0]-newc[0], old[1]-newc[1], old[2]-newc[2]];
        // distribute error
        // x+1, y    -> 7/16
        if(x+1 < w){ data[(y*w+(x+1))*4 +0] = clamp(data[(y*w+(x+1))*4 +0] + err[0]*7/16,0,255);
                      data[(y*w+(x+1))*4 +1] = clamp(data[(y*w+(x+1))*4 +1] + err[1]*7/16,0,255);
                      data[(y*w+(x+1))*4 +2] = clamp(data[(y*w+(x+1))*4 +2] + err[2]*7/16,0,255); }
        // x-1, y+1 -> 3/16
        if(x-1>=0 && y+1<h){ data[((y+1)*w+(x-1))*4 +0] = clamp(data[((y+1)*w+(x-1))*4 +0] + err[0]*3/16,0,255);
                             data[((y+1)*w+(x-1))*4 +1] = clamp(data[((y+1)*w+(x-1))*4 +1] + err[1]*3/16,0,255);
                             data[((y+1)*w+(x-1))*4 +2] = clamp(data[((y+1)*w+(x-1))*4 +2] + err[2]*3/16,0,255); }
        // x, y+1   -> 5/16
        if(y+1<h){ data[((y+1)*w+x)*4 +0] = clamp(data[((y+1)*w+x)*4 +0] + err[0]*5/16,0,255);
                    data[((y+1)*w+x)*4 +1] = clamp(data[((y+1)*w+x)*4 +1] + err[1]*5/16,0,255);
                    data[((y+1)*w+x)*4 +2] = clamp(data[((y+1)*w+x)*4 +2] + err[2]*5/16,0,255); }
        // x+1, y+1 -> 1/16
        if(x+1<w && y+1<h){ data[((y+1)*w+(x+1))*4 +0] = clamp(data[((y+1)*w+(x+1))*4 +0] + err[0]*1/16,0,255);
                             data[((y+1)*w+(x+1))*4 +1] = clamp(data[((y+1)*w+(x+1))*4 +1] + err[1]*1/16,0,255);
                             data[((y+1)*w+(x+1))*4 +2] = clamp(data[((y+1)*w+(x+1))*4 +2] + err[2]*1/16,0,255); }
      }
    }
    return data;
  }

  // Create bead grid image (circle per bead) and return PNG dataURL
  function renderBeadsToCanvas(grid, palette, beadPx){
    const w = grid[0].length, h = grid.length;
    const outW = w * beadPx, outH = h * beadPx;
    const c = document.createElement('canvas');
    c.width = outW; c.height = outH;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,outW,outH);
    const r = Math.floor(beadPx/2 - Math.max(1, beadPx*0.06));
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx = grid[y][x];
        const col = palette[idx];
        ctx.beginPath();
        ctx.fillStyle = `rgb(${col[0]},${col[1]},${col[2]})`;
        const cx = x*beadPx + beadPx/2;
        const cy = y*beadPx + beadPx/2;
        ctx.arc(cx,cy,r,0,Math.PI*2);
        ctx.fill();
        // optional outline
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.lineWidth = Math.max(1, beadPx*0.04);
        ctx.stroke();
      }
    }
    return c.toDataURL('image/png');
  }

  // Main process
  generateBtn.addEventListener('click', async ()=>{
    const file = fileEl.files && fileEl.files[0];
    if(!file){ alert('Lütfen önce bir resim seç.'); return; }
    const beadsAcross = parseInt(beadsAcrossEl.value,10) || 48;
    const paletteSize = clamp(parseInt(paletteSizeEl.value,10) || 16, 2, 64);
    const beadPx = clamp(parseInt(beadPxEl.value,10) || 14, 6, 128);
    const useDither = ditherEl.checked;

    const img = await loadImage(file);
    // compute target size (keep aspect)
    const aspect = img.height / img.width;
    const targetW = beadsAcross;
    const targetH = Math.max(1, Math.round(beadsAcross * aspect));

    // draw to small canvas
    const small = document.createElement('canvas');
    small.width = targetW; small.height = targetH;
    const sctx = small.getContext('2d');
    sctx.drawImage(img,0,0,targetW,targetH);
    let imgd = sctx.getImageData(0,0,targetW,targetH);

    // build pixel array
    const pixels = [];
    for(let i=0;i<imgd.data.length;i+=4){
      const a = imgd.data[i+3];
      // treat transparent as white
      const r = imgd.data[i], g = imgd.data[i+1], b = imgd.data[i+2];
      pixels.push([r,g,b]);
    }

    // run k-means to get palette
    // for speed, sample pixels if large
    const sample = pixels.length > 20000 ? sampleArray(pixels, 20000) : pixels;
    const km = kmeansQuantize(sample, Math.min(paletteSize, Math.max(2, Math.floor(paletteSize))));
    // if palette contains fewer centroids than requested (rare), pad by duplicates
    const palette = km.palette.map(c=>[c[0],c[1],c[2]]);
    while(palette.length < paletteSize) palette.push(palette[palette.length-1].slice());

    // apply dithering (optional) on the small image
    let finalData;
    if(useDither){
      finalData = applyDither(imgd.data, targetW, targetH, palette);
    }else{
      finalData = new Uint8ClampedArray(imgd.data);
      // map each pixel to nearest palette color
      for(let y=0;y<targetH;y++){
        for(let x=0;x<targetW;x++){
          const i = (y*targetW + x)*4;
          const idx = nearestColorIndex(palette, finalData[i], finalData[i+1], finalData[i+2]);
          const c = palette[idx];
          finalData[i]=c[0]; finalData[i+1]=c[1]; finalData[i+2]=c[2];
        }
      }
    }

    // build grid indices
    const grid = [];
    for(let y=0;y<targetH;y++){
      const row = [];
      for(let x=0;x<targetW;x++){
        const i = (y*targetW + x)*4;
        const idx = nearestColorIndex(palette, finalData[i], finalData[i+1], finalData[i+2]);
        row.push(idx);
      }
      grid.push(row);
    }

    // render preview to visible canvas (scaled)
    const previewScale = Math.min(1, 640 / (targetW*beadPx));
    const drawW = Math.max(200, targetW*beadPx*previewScale);
    const drawH = Math.max(160, targetH*beadPx*previewScale);
    previewCanvas.width = drawW; previewCanvas.height = drawH;
    // create image from bead render
    const dataURL = renderBeadsToCanvas(grid, palette, Math.round(beadPx*previewScale));
    const tmp = new Image();
    tmp.onload = ()=>{ previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height); previewCtx.drawImage(tmp,0,0); };
    tmp.src = dataURL;

    // fill palette preview
    palettePreview.innerHTML='';
    for(let i=0;i<palette.length;i++){
      const sw = document.createElement('div'); sw.className='sw';
      sw.title = `#${toHex(palette[i])}`;
      sw.style.background = `rgb(${palette[i][0]},${palette[i][1]},${palette[i][2]})`;
      palettePreview.appendChild(sw);
    }

    // store lastGrid for download/export
    lastGrid = {w:targetW,h:targetH,grid,palette};
    downloadBtn.disabled = false; exportCSVBtn.disabled = false;
  });

  // Download PNG of current grid at requested beadPx
  downloadBtn.addEventListener('click', ()=>{
    if(!lastGrid){ alert('Önce oluştur tuşuna bas.'); return; }
    const beadPx = clamp(parseInt(beadPxEl.value,10)||14,6,512);
    const url = renderBeadsToCanvas(lastGrid.grid, lastGrid.palette, beadPx);
    const a = document.createElement('a'); a.href = url; a.download = 'hama_beads.png'; a.click();
  });

  // Export CSV: rows of palette indices and hex colors
  exportCSVBtn.addEventListener('click', ()=>{
    if(!lastGrid) return;
    const rows = [];
    rows.push(['width', lastGrid.w]); rows.push(['height', lastGrid.h]);
    rows.push([]);
    rows.push(['palette_index','hex']);
    for(let i=0;i<lastGrid.palette.length;i++) rows.push([i, '#'+toHex(lastGrid.palette[i])]);
    rows.push([]);
    rows.push(['grid (rows of palette indices)']);
    for(let y=0;y<lastGrid.h;y++) rows.push(lastGrid.grid[y].join(','));
    const csv = rows.map(r => r.join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'hama_beads.csv'; a.click();
    URL.revokeObjectURL(url);
  });

  // Helpers
  function sampleArray(arr, n){
    const out = [];
    for(let i=0;i<n;i++) out.push(arr[Math.floor(Math.random()*arr.length)]);
    return out;
  }
  function toHex(c){
    return ((1<<24) + (c[0]<<16) + (c[1]<<8) + c[2]).toString(16).slice(1).toUpperCase();
  }

  // drag & drop support for convenience
  ['dragenter','dragover'].forEach(ev=>{
    window.addEventListener(ev,e=>{ e.preventDefault(); e.stopPropagation(); });
  });
  window.addEventListener('drop', e=>{
    e.preventDefault(); e.stopPropagation();
    if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) fileEl.files = e.dataTransfer.files;
  });

  </script>
</body>
</html>
